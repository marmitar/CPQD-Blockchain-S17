/// @title Integer Square Root.
/// @author Tiago de Paula <tiagodepalves@gmail.com>
/// @notice Calculate the integer square root $0 \leq n < 2^{256}$.
/// @dev Based on <https://github.com/PaulRBerg/prb-math/blob/v4.1.0/src/Common.sol#L587-L675>.
PUSH0
CALLDATALOAD
/// Stack: x

/// Special case for 0, to avoid division by zero.
DUP1
ISZERO
PUSH1 0xcf
JUMPI
/// Stack: x

/// Find the closest power of two: $x_0 = 2^{\lfloor \log_2(x) / 2 \rfloor}$.
// xAux = x
DUP1
// result = 1
PUSH1 0x01
// if (xAux >= 2 ** 128)
DUP2
PUSH17 0x0100000000000000000000000000000000
GT
PUSH1 0x29
JUMPI
    // xAux >>= 128
    SWAP1
    PUSH1 0x80
    SHR
    // result <<= 64
    SWAP1
    PUSH1 0x40
    SHL
JUMPDEST
// if (xAux >= 2 ** 64)
DUP2
PUSH9 0x010000000000000000
GT
PUSH1 0x41
JUMPI
    // xAux >>= 64
    SWAP1
    PUSH1 0x40
    SHR
    // result <<= 32
    SWAP1
    PUSH1 0x20
    SHL
JUMPDEST
// if (xAux >= 2 ** 32)
DUP2
PUSH5 0x0100000000
GT
PUSH1 0x55
JUMPI
    // xAux >>= 32
    SWAP1
    PUSH1 0x20
    SHR
    // result <<= 16
    SWAP1
    PUSH1 0x10
    SHL
JUMPDEST
// if (xAux >= 2 ** 16)
DUP2
PUSH3 0x010000
GT
PUSH1 0x67
JUMPI
    // xAux >>= 16
    SWAP1
    PUSH1 0x10
    SHR
    // result <<= 8
    SWAP1
    PUSH1 0x08
    SHL
JUMPDEST
// if (xAux >= 2 ** 8)
DUP2
PUSH2 0x0100
GT
PUSH1 0x78
JUMPI
    // xAux >>= 8
    SWAP1
    PUSH1 0x08
    SHR
    // result <<= 4
    SWAP1
    PUSH1 0x04
    SHL
JUMPDEST
// if (xAux >= 2 ** 4)
DUP2
PUSH1 0x10
GT
PUSH1 0x88
JUMPI
    // xAux >>= 4
    SWAP1
    PUSH1 0x04
    SHR
    // result <<= 2
    SWAP1
    PUSH1 0x02
    SHL
JUMPDEST
// if (xAux >= 2 ** 2)
SWAP1
PUSH1 0x04
GT
PUSH1 0x93
JUMPI
    // result <<= 1
    PUSH1 0x01
    SHL
JUMPDEST
/// Stack: result, x

/// Now we have 1 bit correct of $\sqrt{x}$. The next 7 iterations of Newton's method will expand it into 256 bits.
// 1: result = (result + x / result) >> 1
DUP1
DUP3
DIV
ADD
PUSH1 0x01
SHR
// 2: result = (result + x / result) >> 1
DUP1
DUP3
DIV
ADD
PUSH1 0x01
SHR
// 3: result = (result + x / result) >> 1
DUP1
DUP3
DIV
ADD
PUSH1 0x01
SHR
// 4: result = (result + x / result) >> 1
DUP1
DUP3
DIV
ADD
PUSH1 0x01
SHR
// 5: result = (result + x / result) >> 1
DUP1
DUP3
DIV
ADD
PUSH1 0x01
SHR
// 6: result = (result + x / result) >> 1
DUP1
DUP3
DIV
ADD
PUSH1 0x01
SHR
// 7: result = (result + x / result) >> 1
DUP1
DUP3
DIV
ADD
PUSH1 0x01
SHR
/// Stack: result, x

/// If x is not a perfect square, round the result toward zero.
// roundedResult = x / result
DUP1
SWAP2
DIV
// if (!(roundedResult < result))
DUP2
DUP2
LT
PUSH1 0xcf
JUMPI
    // roundedResult = result
    SWAP1

// return roundedResult
JUMPDEST
PUSH0
MSTORE
PUSH1 0x20
PUSH0
RETURN
