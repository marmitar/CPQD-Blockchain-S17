## @title Integer Square Root.
## @author Tiago de Paula <tiagodepalves@gmail.com>
## @notice Calculate the integer square root $0 \leq n < 2^{256}$.
## @notice Gas usage: exactly 376 gas is used.
## @dev Based on <https://github.com/PaulRBerg/prb-math/blob/v4.1.0/src/Common.sol#L587-L675>.

push0
calldataload
push1 1
## Stack: 1, x

## Find the most significant bit, equivalent to `log2(x)`.
## if x >= 2**128:
push16 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
dup3
gt
# msb7 = (x >= 2**128) ? 128 : 0
push1 7
shl
# x >>= msb7
dup3
dup2
shr
## if x >= 2**64:
push8 0xFFFFFFFFFFFFFFFF
dup2
gt
# msb6 = (x >= 2**64) ? 64 : 0
push1 6
shl
# x >>= msb6
swap1
dup2
shr
## if x >= 2**32:
push4 0xFFFFFFFF
dup2
gt
# msb5 = (x >= 2**32) ? 32 : 0
push1 5
shl
# x >>= msb5
swap1
dup2
shr
## if x >= 2**16:
push2 0xFFFF
dup2
gt
# msb4 = (x >= 2**16) ? 16 : 0
push1 4
shl
# x >>= msb4
swap1
dup2
shr
## if x >= 2**8:
push1 0xFF
dup2
gt
# msb3 = (x >= 2**8) ? 8 : 0
push1 3
shl
# x >>= msb3
swap1
dup2
shr
## if x >= 2**4:
push1 0x0F
dup2
gt
# msb2 = (x >= 2**4) ? 4 : 0
push1 2
shl
# x >>= msb2
swap1
dup2
shr
## if x >= 2**2:
push1 0x04
lt
# msb1 = (x >= 2**2) ? 2 : 0
dup8
shl
# SKIPPED: x >>= msb2
# SKIPPED: msb0 = (x >= 2**1) ? 1 : 0
# msb = msb1 | msb2 | msb3 | msb4 | msb5 | msb6 | msb7
or
or
or
or
or
or
## Stack: msb, 1, x

## Get the closest power of two: $x_0 = 2^{\lfloor \log_2(x) / 2 \rfloor}$.
## This will be our initial guess for Newton's method, which has at least one bit correct.
dup2
shr
shl
## Stack: root, x

## Now we have 1 bit correct of $\sqrt{x}$. The next 7 iterations of Newton's method will expand it into 256 bits.
## Note: division by zero returns 0, so not an issue here.
# 1: root = (root + x / root) >> 1
dup1
dup3
div
add
push1 1
shr
# 2: root = (root + x / root) >> 1
dup1
dup3
div
add
push1 1
shr
# 3: root = (root + x / root) >> 1
dup1
dup3
div
add
push1 1
shr
# 4: root = (root + x / root) >> 1
dup1
dup3
div
add
push1 1
shr
# 5: root = (root + x / root) >> 1
dup1
dup3
div
add
push1 1
shr
# 6: root = (root + x / root) >> 1
dup1
dup3
div
add
push1 1
shr
# 7: root = (root + x / root) >> 1
dup1
dup3
div
add
push1 1
shr
## Stack: root, x

## For almost perfect squares, Newton's method cycles between `⌊√x⌋` => `⌊√x⌋ + 1`, so we need to round the result down.
# if x / root < x:
dup1
swap2
div
dup2
gt
# x -= 1
swap1
sub
## Stack: root

# return root
push0
mstore
push1 0x20
push0
return
