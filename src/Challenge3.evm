## @title Efficient Integer Square Root method.
## @author Tiago de Paula <tiagodepalves@gmail.com>
## @notice Runtime cost: 333 gas (317 discounting RETURN and CALLDATALOAD logic).
## @dev Based on <https://gist.github.com/Lohann/f01e2558691ba8648f1e5a7c6e8d37da>.

push0
calldataload
push1 1
dup1
# stack: 1, 1, x

## First, we find an approximation for $\log_2(x)$.
##
## The following algorithm does a "binary seach" over the regions of $x$, updating our approximation of $\log_2(x)$
## depending on wether the current value is bigger or lower than threshold (i.e. the highest bit is left or right
## of a specific region). At each iteration, it gives one extra bit of information on the result of $\log_2(x)$.

# if x >= 2**128:
dup3
push16 0xffffffffffffffffffffffffffffffff
lt
# 8th bit: log2(x) |= 128
push1 7
shl
# stack: log2, 1, 1, x

# x' = x >> log2
dup4
dup2
shr
# if x' >= 2**64:
push8 0xffffffffffffffff
lt
# 7th bit: log2(x) |= 64
push1 6
shl
or
# stack: log2, 1, 1, x

# x' = x >> log2
dup4
dup2
shr
# if x' >= 2**32:
push4 0xffffffff
lt
# 6th bit: log2(x) |= 32
push1 5
shl
or
# stack: log2, 1, 1, x

# x' = x >> log2
dup4
dup2
shr
# if x' >= 2**16:
push2 0xffff
lt
# 5th bit: log2(x) |= 16
push1 4
shl
or
# stack: log2, 1, 1, x

# x' = x >> log2
dup4
dup2
shr
# if x' >= 2**8:
push1 0xff
lt
# 4th bit: log2(x) |= 8
push1 3
shl
or
# stack: log2, 1, 1, x

## At this point, our $\log_2(x)$ has the 5 upper bits right, so $k = x >> \log_2(x)$ is a number between 0 and 255.
## We'll use a De Bruijn sequence to approximate the square root of $k$, and then do:
## \[ \sqrt{x} = \sqrt{k} \times 2^{\log_2(x) / 2} \]
##
## Since the EVM can only index 32 in the stack, we'll use the upper 5 bits of $k$ for indexing.
push32 0x02030405060707080809090a0a0a0b0b0b0c0c0c0d0d0d0e0e0e0f0f0f0f1010
# stack: table, log2, 1, 1, x

# k = x >> log2
dup5
dup3
shr
## throw away the first 3 bits
# i = k >> 3
push1 3
shr
byte
# stack: table[i], log2, 1, 1, x

## Here we approximate $\sqrt{x} = \sqrt{k} \times 2^{\log_2(x) / 2}$, which is at least 1 bit correct. It should be
## more, but we had to throw some information away.
swap3
# stack: 1, log2, 1, table[i], x
shr
shl
mul
# stack: root, x

## Now we have 1 bit correct of $\sqrt{x}$, and we need 128 bits for the roots of all `uint256` numbers. Each iteration
## of the Newton's method doubles the precision, so 7 iterations are required.

## Note: division by zero returns 0, giving the correct result for $\sqrt{0}$.
# 1: root = (root + x / root) / 2
dup1
dup3
div
add
push1 1
shr
# 2: root = (root + x / root) / 2
dup1
dup3
div
add
push1 1
shr
# 3: root = (root + x / root) / 2
dup1
dup3
div
add
push1 1
shr
# 4: root = (root + x / root) / 2
dup1
dup3
div
add
push1 1
shr
# 5: root = (root + x / root) / 2
dup1
dup3
div
add
push1 1
shr
# 6: root = (root + x / root) / 2
dup1
dup3
div
add
push1 1
shr
# 7: root = (root + x / root) / 2
dup1
dup3
div
add
push1 1
shr
# stack: root, x

## For almost perfect squares, Newton's method cycles between ⌊√x⌋ and ⌊√x⌋ + 1, so we need to round the result down.
# if x > x / root:
dup1
swap2
div
dup2
gt
# x -= 1
swap1
sub
# stack: root

# return root
push0
mstore
push1 0x20
push0
return
