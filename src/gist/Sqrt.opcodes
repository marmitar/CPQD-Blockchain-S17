// Efficient SQRT method
// Constant gas cost of 307 discounting RETURN and CALLDATALOAD logic, or 325 including everything.
//
// Special thanks to @caironeth for have found a better log2(x) here:
//  - https://github.com/Lohann/openzeppelin-contracts/pull/1
//
// For testing use this tool: https://www.evm.codes/playground?fork=cancun
// Authors:
// - Lohann Paterno Coutinho Ferreira <developer@lohann.dev>
// - Cairo <https://github.com/cairoeth>
// - Tiago de Paula <tiagodepalves@gmail.com>

// LOAD X
PUSH0
CALLDATALOAD

// ------ 2 ** (log2(x) / 2) ------

// If value has upper 128 bits set, log2 result is at least 128
DUP1                                       // stack: x x
PUSH16 0xffffffffffffffffffffffffffffffff  // stack: 2**128-1 x x
LT                                         // stack: x>=2**128 x
PUSH1 7                                    // stack: 7 x>=2**128 x
SHL                                        // stack: ±log2(x) x

// If upper 64 bits of 128-bit half set, add 64 to result
// stack: log2(x) 1 x
DUP2                     // stack: x ±log2(x) x
DUP2                     // stack: ±log2(x) x ±log2(x) x
SHR                      // stack: x/±log2(x) ±log2(x) x
PUSH8 0xffffffffffffffff // stack: 2**64-1 x/±log2(x) ±log2(x) x
LT                       // stack: (x/2**±log2(x) >= 2**64) ±log2(x) x
PUSH1 6                  // stack: 6 (x/2**±log2(x) >= 2**64) ±log2(x) x
SHL                      // stack: ±log2(x) ±log2(x) x
OR                       // stack: ±log2(x) x

// If upper 32 bits of 64-bit half set, add 32 to result
DUP2
DUP2
SHR
PUSH4 0xffffffff
LT
PUSH1 5
SHL
OR

// If upper 16 bits of 32-bit half set, add 16 to result
DUP2
DUP2
SHR
PUSH2 0xffff
LT
PUSH1 4
SHL
OR

// If upper 8 bits of 16-bit half set, add 8 to result
DUP2
DUP2
SHR
PUSH1 0xff
LT
PUSH1 3
SHL
OR // stack: ±log2(x) x

// Table lookup
PUSH32 0x02030405060707080809090a0a0a0b0b0b0c0c0c0d0d0d0e0e0e0f0f0f0f1010
// stack: table ±log2(x) x
DUP3  // stack: x table ±log2(x) x
DUP3  // stack: ±log2(x) x table ±log2(x) x
SHR   // stack: 8*i table ±log2(x) x
PUSH1 3
SHR   // stack: i table ±log2(x) x
BYTE  // stack: table[i] ±log2(x) x

// Initial guess: ±sqrt(x) := table[i] * 2**(±log2(x)/2)
SWAP1 // stack: ±log2(x) table[i] x
PUSH1 1
SHR   // stack: ±log2(x)/2 table[i] x
SHL   // stack: ±sqrt(x) x
// ---------------------------------

// Newton's method
// r = (r + x/r) / 2
DUP1
DUP3
DIV
ADD
PUSH1 1
SHR

DUP1
DUP3
DIV
ADD
PUSH1 1
SHR

DUP1
DUP3
DIV
ADD
PUSH1 1
SHR

DUP1
DUP3
DIV
ADD
PUSH1 1
SHR

DUP1
DUP3
DIV
ADD
PUSH1 1
SHR

DUP1
DUP3
DIV
ADD
PUSH1 1
SHR

DUP1
DUP3
DIV
ADD
PUSH1 1
SHR

// y = x/r
DUP1
SWAP2
DIV

// min(r, x/r)
DUP2
GT
SWAP1
SUB

// Return result
PUSH0
MSTORE
PUSH1 32
PUSH0
RETURN
